---
title: "A potential method for replacing zero catches in time series for REMA fitting"
author: "William T. Stockhausen"
institute: NOAA/NMFS/AFSC
date: '`r format(Sys.time(), "%b %e, %Y")`'
fontsize: 11pt 
number-sections: true
number-depth: 2
reference-location: document
bibliography: '`r path.expand("~/Work/Projects/Bibliography/AllRefs.bib")`'
csl: '`r system.file("files/CJFAS.csl",package="wtsQMD")`'
link-citations: true
crossref:
  chapters: false      # prepend label reference numbers by chater number?
  fig-title: Figure    # for caption: default is "Figure")
  tbl-title: Table     # for caption: default is "Table")
  title-delim: "."     # for caption: default is ":")
  fig-prefix: Figure   # for in-text (use [-@fig-ref] to drop prefix in text)
  tbl-prefix: Table    # for in-text (use [-@tbl-ref] to drop prefix in text)
  fig-labels: arabic    # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  tbl-labels: arabic    # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  subref-labels: alpha a # options are arabic, roman, roman i, alpha x, alpha X; latter two starting from x/X
  ref-hyperlink: true    # references are hyperlinked if true
format: 
  html: 
    df-print: paged
    toc: true
    toc-location: right
    fig-width: 8
    fig-asp: 1.4
    fig-dpi: 100
    embed-resources: true
    include-in-header: 
      - '`r system.file("files/in-line_math_mode.html",package="wtsQMD")`'
  pdf:
    documentclass: scrartcl
    toc: false
    fig_crop: false
    keep-tex: false
    geometry:
      - left=1.0in
      - right=1.0in
      - top=1.0in
      - bottom=1.0in
      - textwidth=6.5in
      - showframe=false
    include-in-header: 
       #include '\usepackage{nopageno}' in header to turn off page numbering
      - text: |
          \usepackage{placeins}
          \extrafloats{500}
          \maxdeadcycles=10000
          \usepackage{nopageno}
      - file: '`r system.file("files/ltx_ExtraLatexIncludes.tex",package="wtsQMD")`'
echo: false
warning: false
results: 'hide'
keep-md: false
keep-yaml: false
editor: source
editor_options: 
  chunk_output_type: console
concordance: true
params:
  setup: !expr 'system.file("files/qmd_setup.R",package="wtsQMD")'
  rdaAsmtSetup: "rda_AssessmentSetup.RData"
  testing: false
  reorderTables: false   #--issue with finding "range" of table values  (don't use)
  reorderFigures: false   #--issue with finding "range" of figure values (don't use)
---
<!-- IMPORTANT: if used as a child doc, all chunk labels must be unique within the overall document -->

<!-- 
  NOTEs: 
     * child_path$peek() gives path to current script.
     * before starting a child document, do 
         "child_path$push(file.path(child_path$peek(),rel_path))" first, 
         where rel_path is the relative path to the child
     * after a child document has finished, do "child_path$pop()" to return to current path value
-->

<!-- if not child doc, set up required objects -->
```{r}
#| label: Zeros_setup
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  testing = params$testing;
  if (testing) cat(params$setup,"\n\n")
  source(params$setup);
  if (testing) cat("root = ",root,"\n\n")
  reorderTables  = params$reorderTables;
  reorderFigures = params$reorderFigures;
```

```{r}
#| label: setup_Zeros
#| results: asis
  require(ggplot2);
  require(kableExtra);
  require(tables);
  Sum = wtsUtilities::Sum;
  old_thm = ggplot2::theme_set(cowplot::theme_cowplot(font_size = 10) +
                               cowplot::background_grid() +
                               cowplot::panel_border());
  thm = wtsPlots::getStdTheme();
  options("readr.show_col_types"=FALSE);
  if (testing) cat("dirThs =",child_path$peek(),"\n\n")
  if (!exists("setup")){
    fn = ifelse(child_path$peek()!="",
                file.path(child_path$peek(),"..",params$rdaAsmtSetup),
                file.path(rstudioapi::getActiveProject(),
                          params$rdaAsmtSetup));
    #--for debugging: fn = file.path(rstudioapi::getActiveProject(),"rda_AssessmentSetup.RData");
    setup = wtsUtilities::getObj(fn);
  }

  if (!exists("tblno")) tblno = 0;#--index in LETTERS for tables in text
```

# Introduction

```{r}
  #--load survey data (input biomass units: 1000's t)----
  lstSrv = wtsUtilities::getObj(setup$fnData_TSs);
  dfr = lstSrv$dfrACD.ByX.PD |>
          dplyr::filter(SEX=="mature males") |>
          dplyr::mutate(year=YEAR,
                        area=STRATUM_AREA,
                        numIndvs=numIndivs,
                        numHls=numHauls,
                        numNon0=numNonZeroHauls,
                        totAbd=1000*totABUNDANCE,       #--thousands of individuals
                        cvAbd=cvABUNDANCE,
                        totBio=1000*totBIOMASS,         #--in t
                        cvBio=cvBIOMASS,
                        mnWgt=(totBIOMASS/totABUNDANCE)/1000,  #--in t
                        .keep="none");#--keep only columns created here
  
  #--calculate median mean mature male weight----
  mmWgt = median(dfr$mnWgt,na.rm=TRUE);#--in t
  
  #--assumed area swept----
  As = 0.012; # square nmi
  
  #--define function to calculate density that yields Pr(N=0) = p given area swept and K hauls
  calcDensity<-function(p,K,As){
    d = -(1/(K*As))*log(p);
    return(d);
  }
```

Mature male abundance and biomass of Pribilof Islands blue king crab in the annual NMFS EBS bottom trawl survey has declined substantially since the survey was initiated in 1975 ([@fig-SrvAbdBio]), including zero catches at 86 and 70 survey stations in, respectively, the 2023 and 2024 surveys. The existence of zeros in the corresponding time series for design-based estimates of mature male biomass within the Pribilof Islands survey strata poses methodological difficulties for time series modeling approaches like `rema` [@rema] that model variability on the log scale. `rema` provides three options for dealing with zeros in an observed time series: 1) treat the zeros as missing data; 2) substitute a small, but arbitrary, value for the zeros; 3) assume an error distribution based on the Tweedie distribution. For the latter two options, an associated error CV (coefficient of variation) must also be specified. Lognormal error distributions are assumed under the first two options; using the Tweedie distribution has the advantage that it can synthetically fit zeros in the data, but at the cost of estimating an extra parameter (related to the variance) and is known to experience issues with convergence when finding the maximum likelihood.

```{r}
#| label: fig_SrvAbdBio
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ##--plot number of non-0 hauls by year----
  p1 = ggplot(dfr,aes(x=year)) + 
        geom_ribbon(aes(ymin=totAbd*(1-cvAbd),ymax=totAbd*(1+cvAbd)),alpha=0.2) + 
        geom_line(aes(y=totAbd),colour="blue") + geom_point(aes(y=totAbd),colour="blue") +
        scale_y_log10() +
        labs(x="year",y="Total Abundance (1,0000's)") +
        wtsPlots::getStdTheme();
  p2 = ggplot(dfr,aes(x=year)) + 
        geom_ribbon(aes(ymin=totBio*(1-cvBio),ymax=totBio*(1+cvBio)),alpha=0.2) + 
        geom_line(aes(y=totBio),colour="blue") + geom_point(aes(y=totBio),colour="blue") +
        scale_y_log10(limits=c(10,NA),oob=scales::squish,breaks=c(1,10,100,1000,10000)) +
        labs(x="year",y="Total Biomass (t)") +
        wtsPlots::getStdTheme();
  pg = cowplot::plot_grid(p1,p2,ncol=1);
  lbl = wtsQMD::getLabel();
  cap = paste0("Estimated total survey abundance (upper plot) and biomass (lower plot) ",
               "for PIBKC mature males. The ribbons indicate +/- 1 standard error.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(pg,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
#| label: fig_Non0sbyYear
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 0.5
  ##--plot number of non-0 hauls by year----
  p = ggplot(dfr,aes(x=year)) +
        geom_line(aes(y=numNon0),colour="blue") + geom_point(aes(y=numNon0),colour="blue") +
        scale_y_log10() +
        labs(x="year",y="number of non-0 hauls") +
        wtsPlots::getStdTheme();
  lbl = wtsQMD::getLabel();
  cap = paste0("The number of NMFS EBS survey hauls with non-zero catch of mature males, by year.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
#| label: fig_Non0sbyAbd
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 0.5
  ##--plot number of non-0 hauls by total abundance----
  p = ggplot(dfr,aes(x=numNon0)) +
        geom_path(aes(y=totAbd,colour=year)) + geom_point(aes(y=totAbd,colour=year)) +
        geom_smooth(aes(y=totAbd),alpha=0.2) +
        scale_y_log10() +
        scale_colour_viridis_c(option="magma") +
        labs(x="number of non-0 hauls",y="total abundance (1,000's)") +
        wtsPlots::getStdTheme();
  lbl = wtsQMD::getLabel();
  cap = paste0("The number of NMFS EBS survey hauls with non-zero catch of mature males, plotted as a function ",
               "of estimated total abundance.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

Survey sampling is conducted across a grid of stations, with one trawl haul conducted at each station, and estimates of area-level abundance (or biomass) are scaled up from the the average numbers (or biomass) caught in each haul to the area of the survey stratum. Because a typical area swept during a trawl haul is 0.012 square nautical miles (sq. nmi.) and the total stratum area for PIBKC is 28,070 sq. nmi, a single tow covers only about 0.00004% of the stratum area and 86 tows (the typical number conducted before 2024) covers only 0.0037%. The smallest non-zero value for estimated abundance, which occurred in 2008, is 18,256 mature males or 0.65 mature males/sq. nmi. (the result of 1 mature male caught in 1 haul, out of 86 conducted). Given the nature of the survey sampling, it is thus highly unlikely that mature male biomass was actually 0 in either 2023 or 2024 and that these values were the result of the type of sampling variability expected at low, but non-zero, densities. As such, the question for modeling the time series becomes what might be reasonable values to substitute for the zeros. 

The approach proposed here calculates a density, $d$, consistent with a selected probability $p$ of non-detection (i.e., catching zero crab) in $K$ independent hauls, based on the assumption that crab are randomly-distributed across the survey stratum and hauls represent independent samples. Under the assumption that crab are randomly-distributed across the stratum, the number of crab, $N$, caught in a haul swept with area $A_s$ is a Poisson-distributed random variable with: 

$$Pr(N=n|\lambda) = \frac {\lambda^n e^{-\lambda}} {n!}$$
where $\lambda=d \cdot A_s$. The probability of non-detection (no crab are caught) in $K$ independent hauls is just: 

$$ Pr(N=0|\text{K hauls}) = \prod_K e^{-\lambda} = e^{-K \cdot \lambda} $$ 
Setting $p=Pr(N=0|\text{K hauls})$ and rearranging to solve for the density, $d$,, one obtains:

$$d=-\frac{ln(p)}{K \cdot A_s} $$

The associated coefficient of variation (CV) can also be derived: for the sum of $K$ independently-distributed Poisson variables, the expected mean is $K \cdot \lambda$, as is the variance, so the CV ($=variance^{1/2}/mean$) is 

$$CV = \frac {(K \cdot \lambda)^{1/2}}{(K \cdot \lambda)} = (K \cdot \lambda)^{-1/2}=(K \cdot d \cdot A_s)^{-1/2}=[-ln(p)]^{-1/2}$$
```{r Zeros_ExCalc}
#--example
ex_d = -log(0.5)/(70*As);
ex_cv = 1/sqrt(-log(0.5));
ex_abd = 28070*ex_d/1000;#--total abundance, in 1,000's
```

Using the formulae above for mature males in 2024 with $p=0.5$ (i.e., 50% chance of obtaining no crab while sampling 70 independent survey hauls), $d =$ `r formatC(ex_d)` mature males/sq. nmi., total abundance = `r formatC(ex_abd)` thousand mature males, and $CV=$ `r formatC(ex_cv)`. Figure [-@fig-PrByD] provides a more comprehensive picture of the dependence of density as a function of the probability of non-detection.


```{r}
#| label: fig_PrByD
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ds = tidyr::expand_grid(p=seq(0.01,0.99,0.01),K=c(1,2,4,8,16,32,48,96)) |>
       dplyr::mutate(d=calcDensity(p,K,As));
  p1 = ggplot(ds,aes(x=d,y=p,colour=as.factor(K),group=as.factor(K))) +
        geom_line() +
        labs(x="density (number crab/sq. nmi.)",y="Pr(N=0|K hauls)",colour="number\nhauls");
  p2 = ggplot(ds |> dplyr::filter(d<50),
              aes(x=d,y=p,colour=as.factor(K),group=as.factor(K))) +
        geom_line() +
        labs(x="density (number crab/sq. nmi.)",y="Pr(N=0|K hauls)",colour="number\nhauls");
  pg = cowplot::plot_grid(p1,p2,ncol=1);
  lbl = wtsQMD::getLabel();
  cap = paste0("The probability of non-detection (zero catch), by crab density (x-axis) and ",
               "number of hauls (color scale). ",
               "Densities (x axis) were calculated as a function of the probability of non-detection (y axis) ",
               "and the number of hauls, but the plot has been transposed. The lower plot is limited to ",
               "density < 50 crab/sq. nmi to better show details at low densities.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(pg,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

The total abundance and biomass corresponding to densities yielding a non-detection probability of 0.5, given the number of survey hauls performed each year, are below the estimated total abundance/biomass (solid black line, Figures [-@fig-EstAbdWithNDPs] and [-@fig-EstBioWithNDPs]) in every year except 2008, when only 1 mature male was caught, and 2023 and 2024 (when, of course, no crabs were caught). Reducing the non-detection probability to 0.2 increases the number of years the estimated survey abundance exceeds the non-detection total abundance by 1 (2022), while it increases the corresponding value for biomass by 2 (2004, 2022). Increasing the non-detection probability to 0.8 results in no years other than 2023 and 2024 in which the estimated survey abundance or biomass is less than the non-detection abundance/biomass.

```{r}
  #--calculate densities and equivalent total abundance and biomass----
  ##--use sampled hauls for density calculation----
  dfp = dfr |> dplyr::mutate(d20=calcDensity(0.2,numHls,As), #--density in #/sq nmi
                             d50=calcDensity(0.5,numHls,As),
                             d80=calcDensity(0.8,numHls,As),
                             cvD20=1/sqrt(-log(0.2)),
                             cvD50=1/sqrt(-log(0.5)),
                             cvD80=1/sqrt(-log(0.8)),
                             a20=area*d20/1000,  #--abundance (in 1,000's) expanded to total area
                             a50=area*d50/1000,
                             a80=area*d80/1000,
                             b20=area*d20*mmWgt, #--biomass (in t) expanded to total area
                             b50=area*d50*mmWgt,
                             b80=area*d80*mmWgt
                             );
```

```{r}
#| label: fig_EstAbdWithNDPs
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 0.5
  p = ggplot(dfp,aes(x=year)) +
        geom_line(aes(y=totAbd),colour="blue") + geom_point(aes(y=totAbd),colour="blue") +
        geom_ribbon(aes(ymin=a80,ymax=a20),alpha=0.2) +
        geom_ribbon(aes(ymin=a50*max(c(0,1-cvD50)),ymax=a50*(1+cvD50)),alpha=0.2,fill="green") +
        geom_line(aes(y=a50),colour="green") +
        scale_y_log10() +
        labs(x="year",y="total abundance (1,000's)") +
        wtsPlots::getStdTheme();
  lbl = wtsQMD::getLabel();
  cap = paste0("The estimated time series of mature male total abundance from the NMFS survey ",
               "(blue line and points), with total abundance corresponding to non-detection probabilities ",
               "of 0.5 (green line) and 0.8 and 0.2 (lower and upper bounds ",
               "of grey shading), based on the number of hauls conducted for PIBKC each year. ",
               "The green shading indicates the +/- 1 CV interval for the 0.5 non-detection values.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
#| label: fig_EstBioWithNDPs
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 0.5
  p = ggplot(dfp,aes(x=year)) +
        geom_line(aes(y=totBio),colour="blue") + geom_point(aes(y=totBio),colour="blue") +
        geom_ribbon(aes(ymin=b80,ymax=b20),alpha=0.2) +
        geom_ribbon(aes(ymin=b50*max(c(0,1-cvD50)),ymax=b50*(1+cvD50)),alpha=0.2,fill="green") +
        geom_line(aes(y=b50),colour="green") +
        scale_y_log10() +
        labs(x="year",y="total biomass (t)") +
        wtsPlots::getStdTheme();
  lbl = wtsQMD::getLabel();
  cap = paste0("The estimated time series of mature male total biomass from the NMFS survey ",
               "(blue line and points), with total biomass corresponding to probabilities ",
               "of zero catch of 0.5 (black line) and 0.8 and 0.2 (lower and upper bounds ",
               "of grey shading), based on the number of hauls conducted for PIBKC each year.",
               "The green shading indicates the +/- 1 CV interval for the 0.5 non-detection values.")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

<!-- ```{r} -->
<!--   ##--use median number of non-zero hauls for density calculation---- -->
<!--   mdHls = median(dfr$numNon0); -->
<!--   dfq = dfr |> dplyr::mutate(d20=calcDensity(0.2,mdHls,As), #--density in #/sq nmi -->
<!--                              d50=calcDensity(0.5,mdHls,As), -->
<!--                              d80=calcDensity(0.8,mdHls,As), -->
<!--                              a20=area*d20/1000,  #--abundance (in 1,000's) expanded to total area -->
<!--                              a50=area*d50/1000, -->
<!--                              a80=area*d80/1000, -->
<!--                              b20=area*d20*mmWgt, #--biomass (in t) expanded to total area -->
<!--                              b50=area*d50*mmWgt, -->
<!--                              b80=area*d80*mmWgt -->
<!--                              ); -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| label: fig_MedN0Abd -->
<!-- #| results: asis -->
<!-- #| fig-width: 6.5  -->
<!-- #| fig-asp: 0.5 -->
<!--   p = ggplot(dfq,aes(x=year)) + -->
<!--         geom_line(aes(y=totAbd),colour="blue") + geom_point(aes(y=totAbd),colour="blue") + -->
<!--         geom_ribbon(aes(ymin=a80,ymax=a20),alpha=0.2) + -->
<!--         geom_line(aes(y=a50)) + -->
<!--         scale_y_log10() + -->
<!--         labs(x="year",y="total abundance (1,000's)") + -->
<!--         wtsPlots::getStdTheme(); -->
<!--   lbl = wtsQMD::getLabel(); -->
<!--   cap = paste0("The estimated time series of mature male total abundance from the NMFS survey ", -->
<!--                "(blue line and points), with total abundance corresponding to probabilities ", -->
<!--                "of zero catch of 0.5 (black line) and 0.8 and 0.2 (lower and upper bounds ", -->
<!--                "of grey shading), based on the median number of non-zero hauls conducted ", -->
<!--                "for PIBKC over the time series.") -->
<!--   pth = wtsQMD::getFigFN(); -->
<!--   lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P")); -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #| label: fig_MedN0Bio -->
<!-- #| results: asis -->
<!-- #| fig-width: 6.5  -->
<!-- #| fig-asp: 0.5 -->
<!--   p = ggplot(dfq,aes(x=year)) + -->
<!--         geom_line(aes(y=totBio),colour="blue") + geom_point(aes(y=totBio),colour="blue") + -->
<!--         geom_ribbon(aes(ymin=b80,ymax=b20),alpha=0.2) + -->
<!--         geom_line(aes(y=b50)) + -->
<!--         scale_y_log10() + -->
<!--         labs(x="year",y="total biomass (t)") + -->
<!--         wtsPlots::getStdTheme(); -->
<!--   lbl = wtsQMD::getLabel(); -->
<!--   cap = paste0("The estimated time series of mature male total biomass from the NMFS survey ", -->
<!--                "(blue line and points), with total biomass corresponding to probabilities ", -->
<!--                "of zero catch of 0.5 (black line) and 0.8 and 0.2 (lower and upper bounds ", -->
<!--                "of grey shading), based on the median number of non-zero hauls conducted ", -->
<!--                "for PIBKC over the time series.") -->
<!--   pth = wtsQMD::getFigFN(); -->
<!--   lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P")); -->
<!-- ``` -->

# `rema` results

```{r Zeros_defREMA}
  #--Define function to run rema model with zeros option and generate results and diagnostics as a list----
  runREMA<-function(model_name,dfr,zeros,doMCMC=FALSE){
    if (testing) cat("Running rema model",model_name,"\n")
    resLst = list();
    #--set cv's to NA where value = 0
    dfr = dfr |> dplyr::mutate(cv=ifelse(value==0,NA,cv));
    #--prepare rema input
    inp = rema::prepare_rema_input(
                  model_name="rema",
                  end_year=wtsQMD::last(dfr$year),
                  biomass_dat=tibble::tibble(strata="Pribilof Islands",
                                             year=dfr$year,
                                             biomass=dfr$value,
                                             cv=dfr$cv),
                  zeros = zeros)
    resLst$rema_inp = inp;
  
    #--fit the data
    mdl = rema::fit_rema(inp,
                         n.newton=1,
                         do.sdrep=TRUE,
                         do.check=TRUE,
                         do.fit=TRUE,
                         save.sdrep=TRUE,
                         MakeADFun.silent=TRUE);
    resLst$rema_mdl = mdl;
  
    #--tidy up the model results
    tdy = rema::tidy_rema(mdl,alpha=1-setup$ci);
    resLst$tdy_alpha = 1-setup$ci;
    resLst$tdy_rema  = tdy;
    resLst$tdy_mxIdx = length(tdy$biomass_by_strata$year);
    resLst$tdy_mxYr  = tdy$biomass_by_strata$year[resLst$tdy_mxIdx];
    resLst$dfrSrvMMB = tdy$biomass_by_strata |>
                                       dplyr::mutate(pred_cv=sqrt(exp(sd_log_pred^2)-1)) |>
                                       dplyr::select(year,
                                                     obs,obs_cv,obs_lci,obs_uci,
                                                     pred,pred_cv,pred_lci,pred_uci) |>
                                       dplyr::mutate(pred=unname(pred),
                                                     pred_cv=unname(pred_cv),
                                                     pred_lci=unname(pred_lci),
                                                     pred_uci=unname(pred_uci));
  
    if (testing) print(tdy$parameter_estimates);
  
    if (tolower(zeros$assumption)!="tweedie"){
      #--get one-step-ahead residuals
      osas = rema::get_osa_residuals(mdl);
      resLst$osas = osas;
      if (testing) print(plotOSAs(osas));
    }
  
    #--do MCMC analysis
    if (doMCMC){
      options(mc.cores = parallel::detectCores());
      mcmc = tmbstan::tmbstan(mdl,algorithm="NUTS",laplace=FALSE,chains=8,warmup=5000,iter=25000,thin=4);
      resLst$mcmc_params = list(algorithm="NUTS",laplace=FALSE,chains=8,warmup=5000,iter=25000,thin=4);
      resLst$mcmc = mcmc;
      #----extract diagnostics
      mon = rstan::monitor(mcmc);
      rHat = max(mon$Rhat);    #--potential scale reduction factor: value < 1.05 indicates convergence
      ESS  = min(mon$Tail_ESS);#--minimum effective sample size (should be > 100)
      resLst$mcmc_rHat = rHat;
      resLst$mcmc_ESS  = ESS;
      if (testing) {
        cat("rHat =",rHat,"\n");
        cat("ESS =",ESS,"\n");
      }
      #----extract posterior densities for derived quantities
      dfrPDs = wtsMCMC::mcmcTMB_RunReport(mdl,mcmc,vars="biomass_pred");
      resLst$dfrPDs = dfrPDs;
      if (testing) {
        p = wtsMCMC::mcmcTMB_PlotParamDiagnostics(dfrPDs,
                                                  paste0("biomass_pred[",resLst$tdy_mxIdx,"]"),
                                                  label="terminal MMB");
        print(p)
      }
    }#--doMCMC
    return(resLst);
  }
```

```{r Zeros_RunREMA}
##--create (or read in) list for rema models and results----
if (FALSE){
  lstAll = list();
  lstAll$remas = list();
  
  ##--define "standard" models----
  opt1 = "LN w/ 0's as NAs";
  opt2 = "LN w/ small constant";
  opt3 = "Tweedie w/ CV=1.5";
  zeros1 = list(assumption = 'NA');
  zeros2 = list(assumption = 'small_constant',
                options_small_constant = c(0.01, 1.5)); # values: 1) small constant, 2) assumed CV
  zeros3 = list(assumption = 'tweedie',
                options_tweedie=list(zeros_cv=1.5));
  ##--run standard models----
  dfrp = dfr |> dplyr::select(year,value=totBio,cv=cvBio);
  lstAll$remas[[opt1]] = runREMA(opt1,dfrp,zeros=zeros1,doMCMC=FALSE);
  lstAll$remas[[opt2]] = runREMA(opt2,dfrp,zeros=zeros2,doMCMC=FALSE);
  lstAll$remas[[opt3]] = runREMA(opt3,dfrp,zeros=zeros3,doMCMC=FALSE);#--mcmc very slow
  
  ##--substitute zeros with biomass for non-detection probability 0.5
  dfpp = dfp |> dplyr::select(year,value=totBio,cv=cvBio,b50,cvD50) |> 
            dplyr::mutate(cv=ifelse(value>0,cv,cvD50),
                          value=ifelse(value>0,value,b50)) |> #--need to do this last
            dplyr::select(year,value,cv);
  opt4 = "LN w/ p=0.5"
  opt5 = "Tweedie w/ p=0.5";
  lstAll$remas[[opt4]] = runREMA(opt4,dfpp,zeros=zeros1,doMCMC=FALSE);
  lstAll$remas[[opt5]] = runREMA(opt5,dfpp,zeros=zeros3,doMCMC=FALSE);#--mcmc very slow
  
  #--compare model estimates----
  require(ggplot2)
  lstTmp = list();
  for (opt in names(lstAll$remas)){
    #--testing: opt = names(lstAll$remas)[1];
    rma = lstAll$remas[[opt]];
    lstTmp[[opt]] = rma$dfrSrvMMB |> dplyr::mutate(option=opt);
  }
  dfrTmp = dplyr::bind_rows(lstTmp); rm(lstTmp);
  compareOpts<-function(dfrTmp,ymax=NA,dfrLast=NULL){
    dfrDat = dfrTmp |> dplyr::distinct(year,obs,obs_lci,obs_uci);
    p1 = ggplot(dfrTmp,aes(x=year,y=pred,ymin=pred_lci,ymax=pred_uci,colour=option,fill=option)) +
          geom_errorbar(data=dfrDat,mapping=aes(x=year,y=obs,ymin=obs_lci,ymax=obs_uci),inherit.aes=FALSE) +
          geom_point(data=dfrDat,mapping=aes(x=year,y=obs),inherit.aes=FALSE);
    if (!is.null(dfrLast)){
      p1 = p1 +
            geom_ribbon(data=dfrLast,mapping=aes(x=year,y=pred,ymin=pred_lci,ymax=pred_uci),
                        colour=NA,fill="red",alpha=0.5,inherit.aes=FALSE) +
            geom_line(data=dfrLast,mapping=aes(x=year,y=pred),colour="red",inherit.aes=FALSE)
    }
    p1 = p1 +
          geom_ribbon(alpha=0.5,colour=NA) + geom_line() +
          scale_y_continuous(limits=c(0,ymax),oob=scales::squish) +
          scale_fill_viridis_d(aesthetics=c("fill","colour")) +
          labs(y="biomass (t)") +
          theme(legend.position=c(0.99,0.99),
                legend.justification=c(1,1)) +
          wtsPlots::getStdTheme();
    p2 = p1 + scale_y_log10();
    pg = cowplot::plot_grid(p1+theme(axis.title.x=element_blank()),
                            p2+theme(legend.position="none"),
                            ncol=1);
    return(pg);
  }
  lstAll$compareOpts = compareOpts;
  lstAll$dfrPrds = dfrTmp;
  wtsUtilities::saveObj(lstAll,file.path(child_path$peek(),"rda_Zeros_REMA_Models.RData"));
} else {
  ##--read in previous results
  lstAll = wtsUtilities::getObj(file.path(child_path$peek(),"rda_Zeros_REMA_Models.RData"));
  compareOpts = lstAll$compareOpts;
  opt1 = names(lstAll$remas)[1];
  opt2 = names(lstAll$remas)[2];
  opt3 = names(lstAll$remas)[3];
  opt4 = names(lstAll$remas)[4];
  opt5 = names(lstAll$remas)[5];
}
```
```{r}
#| label: fig_CompareAll1
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
##--compare all----
  p = compareOpts(lstAll$dfrPrds,ymax=50000,
                  dfrLast=lstAll$dfrSrvMMB_last);
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```
```{r}
#| label: fig_CompareAll2
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
##--compare all----
  p = compareOpts(lstAll$dfrPrds |> dplyr::filter(year>=2010));
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```
```{r}
#| label: fig_CompareLNs1
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ##--compare lognormals----
  dfrs = lstAll$dfrPrds |> dplyr::filter(option %in% c(opt2,opt4))
  p = compareOpts(dfrs,ymax=50000,
                  dfrLast=lstAll$dfrSrvMMB_last);
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```
```{r}
#| label: fig_CompareLNs2
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ##--compare lognormals----
  p = compareOpts(dfrs |> dplyr::filter(year>=2010));
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
#| label: fig_CompareTWs1
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ##--compare Tweedies----
  dfrs = lstAll$dfrPrds |> dplyr::filter(option %in% c(opt3,opt5))
  p = compareOpts(dfrs,ymax=50000,
                  dfrLast=lstAll$dfrSrvMMB_last);
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```
```{r}
##--compare Tweedies----
#| label: fig_CompareTWs2
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  p = compareOpts(dfrs |> dplyr::filter(year>=2010))
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
##--compare p=0.5's----
#| label: fig_ComparePs1
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  dfrs = lstAll$dfrPrds |> dplyr::filter(option %in% c(opt4,opt5))
  p = compareOpts(dfrs,ymax=50000,
                  dfrLast=lstAll$dfrSrvMMB_last);
```
```{r}
#| label: fig_ComparePs2
#| results: asis
#| fig-width: 6.5 
#| fig-asp: 1.0
  ##--compare p=0.5's----
  p = compareOpts(dfrs |> dplyr::filter(year>=2010))
  lbl = wtsQMD::getLabel();
  cap = paste0("")
  pth = wtsQMD::getFigFN();
  lstFigs = c(lstFigs,wtsQMD::printGGplot(p,lbl=lbl,cap=cap,pth=pth,ori="P"));
```

```{r}
logit_tw_p = unname(lstAll$remas[["Tweedie w/ p=0.5"]]$rema_mdl$sdrep$par.fixed[2]);
tw_p_LB = 1;#--lower arithmetic-scale bound
tw_p_UB = 2;#--upper arithmetic-scale bound
tw_p = tw_p_LB + (tw_p_UB-tw_p_LB)*1/(1+exp(-logit_tw_p));
dfrRTs = tibble::tribble(~option,~time,
                          opt1,lstAll$remas[[opt1]]$rema_mdl$runtime,
                          opt2,lstAll$remas[[opt2]]$rema_mdl$runtime,
                          opt3,lstAll$remas[[opt3]]$rema_mdl$runtime,
                          opt4,lstAll$remas[[opt4]]$rema_mdl$runtime,
                          opt5,lstAll$remas[[opt5]]$rema_mdl$runtime);
```

The model assuming a Tweedie error distribution and using the $p = 0.5$ criteria may not have converged (the max gradient was `r formatC(lstAll$remas[["Tweedie w/ p=0.5"]]$rema_mdl$final_gradient[2])` while the variance parameter was estimated essentially at its arithmetic upper bound (estimate = `r formatC(tw_p,digits=6)`, upper bound = 2). In addition, it took `r as.numeric(dfrRTs$time[5])` seconds for this model to converge as compared with < 1s for the other models.

#  Summary and Recommendations

This report presented a novel approach to "fill in" zeros in a survey abundance or biomass time series to facilitate time series modeling, in particular with the `rema` R package [@rema], based on substituting abundance/biomass values and CVs determined from a user-selected probability of non-detection in place of the zeros. The utility of this approach was explored using annual survey time series for Pribilof Islands blue king crab mature male abundance and biomass; zeros occurred in these time series in 2023 and 2024. `rema` provides three options for dealing with zeros, two for lognormal error distributions (treat 0's as NAs/ignore as missing; substitute a small value for zeros, and a large value for its CV) and one for a Tweedie error distribution (specify a large CV). In the first case, the predicted value for any zero-value observation is the same as the previous predicted value, while its uncertainty increases--the prediction treats the zero-value observation as if it did not occur. In the second case, a small value is provided, together with a large CV, but the values chosen are rather arbitrary and the resulting predictions are generally very sensitive to the values chosen. Using the Tweedie error distribution, the third case, is intuitively attractive because it allows for zero-value observations whereas the lognormal does not. However, it does require that the user specify a non-zero CV for any zeros and models using the Tweedie distribution have been found to take a very long time to converge, in some cases.

The approach taken here is to recognize that, for populations at low densities relative to the sampling effort, zero-value catches may be the rule rather than the exception--and to use sampling theory to guide the choice of substitute values for the observed non-detection and associated CV. In the simplest case, the sampling of individuals randomly-distributed across a seascape follows a Poisson distribution, which yields a particularly simple form for the probability of obtaining a series of zero-value catches as a function of the density of those individuals. We inverted this relationship to determine the density that would yield a given probability of non-detection over a given number of survey hauls. For the Poisson distribution, this also allowed us to determine an appropriate CV

```{r}
#| label: refs_Zeros
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  cat("# References {-}\n")
  cat("::: {#refs}\n")
  cat(":::\n\n")
```

<!-- tables, if not child doc and lstTbls is not empty -->
```{r}
#| label: tables_Zeros
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  source(system.file("files/printTablesSectionFromList.R",package="wtsQMD"));
```

<!-- figures, if not child doc and lstFigs is not empty -->
```{r}
#| label: figures_Zeros
#| eval: !expr '!knitr::opts_knit$get("child")'
#| results: asis
  source(system.file("files/printFiguresSectionFromList.R",package="wtsQMD"));
```

